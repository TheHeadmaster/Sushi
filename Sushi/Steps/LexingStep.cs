using System.Collections.ObjectModel;
using System.Diagnostics.CodeAnalysis;
using Serilog;
using Sushi.Extensions;
using Sushi.Lexing.Tokenization;

namespace Sushi.Steps;

/// <summary>
/// Handles scanning and lexing of source files.
/// </summary>
public sealed class LexingStep : ICompilerStep
{
    /// <summary>
    /// The source files generated by this step.
    /// </summary>
    private readonly List<TokenFile> sourceFiles = [];

    /// The list of token generators used to create tokens during the lexing process.
    private readonly ReadOnlyCollection<TokenGenerator> generators = [.. ReflectionEx.GetLeafSubclasses<TokenGenerator>()];

    /// <inheritdoc />
    public int StepNumber => 1;

    /// <inheritdoc />
    public async Task Initialize([NotNull] CompileJob job)
    {
        DateTime startTime = DateTime.Now;
        Log.Information("Initializing lexer...");

        Log.Information("Loading source files from disk...");

        List<Task<TokenFile>> fileTasks = [];

        foreach (string file in Directory.EnumerateFiles(AppMeta.Options.ProjectPath, "*.sus", SearchOption.AllDirectories))
        {
            fileTasks.Add(Task.Run(() => LoadFile(file)));
        }

        await Task.WhenAll(fileTasks);

        this.sourceFiles.AddRange(fileTasks.Select(task => task.Result));

        Log.Information("Loaded all source files in {Time}.", startTime.TimeSinceAsString());
    }

    /// <summary>
    /// Loads the specified file from disk and translates it into a raw, unprocessed <see cref="TokenFile"/>.
    /// </summary>
    /// <param name="file">
    /// The path of the file.
    /// </param>
    /// <returns>
    /// An awaitable <see cref="Task"/> that returns the raw <see cref="TokenFile"/> object.
    /// </returns>
    private static async Task<TokenFile> LoadFile([NotNull] string file)
    {
        string source = await File.ReadAllTextAsync(file);

        Log.Information("Loaded file {File}.", Path.GetRelativePath(AppMeta.Options.ProjectPath, file));

        return new() { FileName = Path.GetFileName(file), FilePath = file, RawSourceCode = source };
    }

    /// <inheritdoc />
    public async Task Run([NotNull] CompileJob job)
    {
        DateTime startTime = DateTime.Now;

        Log.Information("Lexing files...");

        List<Task> fileTasks = [];

        foreach (TokenFile file in this.sourceFiles)
        {
            fileTasks.Add(Task.Run(() => this.LexFile(file)));
        }

        await Task.WhenAll(fileTasks);

        job.SourceFiles = this.sourceFiles;

        int errorCount = this.sourceFiles.SelectMany(x => x.Tokens).Count(x => x.Type == TokenType.Unknown);

        Log.Information("{FileCount} files were lexed in {Time} with {ErrorCount} syntax errors.", this.sourceFiles.Count, startTime.TimeSinceAsString(), errorCount);

        if (errorCount > 0)
        {
            Program.Exit(ExitCode.LexingSyntaxError);
        }
    }

    /// <summary>
    /// Lexes a <see cref="TokenFile"/> into a list of tokens.
    /// </summary>
    /// <param name="file">
    /// The file to lex.
    /// </param>
    /// <returns>
    /// An awaitable <see cref="Task"/>.
    /// </returns>
    private async Task LexFile([NotNull] TokenFile file)
    {
        Log.Information("Lexing file {File}...", Path.GetRelativePath(AppMeta.Options.ProjectPath, file.FilePath));

        while (!file.LastIndexOfFileReached())
        {
            await this.GetTokenWithHighestAffinity(file);
        }
    }

    /// <summary>
    /// Runs through the list of token generators and tries to generate a token, then chooses the one with the highest affinity.
    /// If no generators generate a valid token, then an unknown token is generated and consumes a char at a time until a generator makes a valid token.
    /// </summary>
    /// <param name="file">
    /// The file to get the next token for.
    /// </param>
    /// <returns>
    /// An awaitable <see cref="Task"/>.
    /// </returns>
    private async Task GetTokenWithHighestAffinity([NotNull] TokenFile file)
    {
        IEnumerable<Task<TokenGeneratorResult>> tasks = this.generators.Select(generator => generator.TryGenerate(file));

        await Task.WhenAll(tasks);

        TokenGeneratorResult? nominatedToken = tasks
            .Select(x => x.Result)
            .Where(x => x.CanGenerate)
            .OrderByDescending(token => token.Affinity)
            .ThenByDescending(token => token.ConsumedCharacters)
            .FirstOrDefault();

        if (nominatedToken is null)
        {
            Token? lastToken = file.Tokens.LastOrDefault();

            if (lastToken is null || lastToken.Type is not TokenType.Unknown)
            {
                await ReportSyntaxError(file);
                file.Tokens.Add(new Token
                {
                    Type = TokenType.Unknown,
                    Value = file.GetNextChar()?.ToString() ?? string.Empty,
                    LineNumber = file.GetLineNumber(),
                    LinePosition = file.GetLinePosition(),
                });
                file.CurrentPosition++;
                return;
            }

            lastToken.Value += file.GetNextChar()?.ToString() ?? string.Empty;
            file.CurrentPosition++;
            return;
        }

        if (nominatedToken.Token is null)
        {
            Log.Error("Sushi Lexer emitted a null token");
            Program.Exit(ExitCode.LexingSyntaxError);
        }

        file.Tokens.Add(nominatedToken.Token);
        file.CurrentPosition += nominatedToken.ConsumedCharacters ?? 0;
    }

    /// <summary>
    /// Reports a syntax error with a visual cue on the exact line number and position that the error occurred.
    /// </summary>
    /// <param name="source">
    /// The source file the error happened in.
    /// </param>
    /// <returns>
    /// An awaitable <see cref="Task"/>.
    /// </returns>
    private static Task ReportSyntaxError(TokenFile source)
    {
        Log.Error("Invalid syntax at Line {LineNumber} Position {LinePosition}\n{Line}\n{Padding}^",
            source.GetLineNumber(), source.GetLinePosition(), source.GetCurrentLine(), new string(' ', source.GetLinePosition()));

        return Task.CompletedTask;
    }
}
