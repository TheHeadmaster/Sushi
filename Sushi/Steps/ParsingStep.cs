using System.Collections.ObjectModel;
using System.Diagnostics.CodeAnalysis;
using Serilog;
using Sushi.Extensions;
using Sushi.Lexing.Tokenization;
using Sushi.Parsing;
using Sushi.Parsing.Nodes;

namespace Sushi.Steps;

/// <summary>
/// Handles parsing of tokens into an abstract syntax tree.
/// </summary>
public sealed class ParsingStep : ICompilerStep
{
    /// <summary>
    /// The source files generated by this step.
    /// </summary>
    private readonly AbstractSyntaxTree syntaxTree = new();

    /// <inheritdoc />
    public int StepNumber => 2;

    /// <inheritdoc />
    public async Task Initialize([NotNull] CompileJob job)
    {
        DateTime startTime = DateTime.Now;

        Log.Information("Initializing parser...");

        this.syntaxTree.Children.AddRange(job.SourceFiles.Select(file => new FileNode()
        {
            RawSourceCode = file.RawSourceCode,
            FileName = file.FileName,
            FilePath = file.FilePath,
            Tokens = file.Tokens,
            LineNumber = 1,
            LinePosition = 0
        }));

        Log.Information("Initialized parser in {Time}.", startTime.TimeSinceAsString());
    }

    /// <inheritdoc />
    public async Task Run([NotNull] CompileJob job)
    {
        DateTime startTime = DateTime.Now;

        Log.Information("Parsing files...");

        List<Task<ParsingContext>> fileTasks = [];

        foreach (FileNode node in this.syntaxTree.Children.OfType<FileNode>())
        {
            fileTasks.Add(Task.Run(() => ParseFile(node)));
        }

        await Task.WhenAll(fileTasks);

        job.SyntaxTree = this.syntaxTree;

        List<CompilerError> errors = [..fileTasks.SelectMany(context => context.Result.Errors)];

        foreach (CompilerError error in errors)
        {
            await ReportCompilerError(error);
        }

        Log.Information("{FileCount} files were parsed in {Time} with {ErrorCount} compiler errors.", this.syntaxTree.Children.Count, startTime.TimeSinceAsString(), errors.Count);

        if (errors.Count > 0)
        {
            Program.Exit(ExitCode.ParsingSyntaxError);
        }
    }

    /// <summary>
    /// Parses a <see cref="FileNode"/> into a syntax tree.
    /// </summary>
    /// <param name="file">
    /// The file to parse.
    /// </param>
    /// <returns>
    /// An awaitable <see cref="Task"/>.
    /// </returns>
    private static async Task<ParsingContext> ParseFile([NotNull] FileNode file)
    {
        Log.Information("Parsing file {File}...", Path.GetRelativePath(AppMeta.Options.ProjectPath, file.FilePath));

        ParsingContext context = new() { Tokens = file.Tokens };

        if (!await file.Visit(context))
        {
            context.Errors.Add(new CompilerError(context.Peek()!) { ErrorReason = "Token was not able to be handled" });
        }

        return context;
    }

    /// <summary>
    /// Reports a compiler error with a visual cue on the exact line number and position that the error occurred.
    /// </summary>
    /// <param name="source">
    /// The source file the error happened in.
    /// </param>
    /// <returns>
    /// An awaitable <see cref="Task"/>.
    /// </returns>
    private static Task ReportCompilerError(CompilerError error)
    {
        Log.Error("{ErrorReason} at {LineNumber} Position {LinePosition}\n{Line}\n{Padding}^", error.ErrorReason,
            error.LineNumber, error.LinePosition, error.CurrentLine, new string(' ', error.LinePosition));

        return Task.CompletedTask;
    }
}
