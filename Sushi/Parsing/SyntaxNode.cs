using System.Diagnostics.CodeAnalysis;
using Sushi.Lexing.Tokenization;

namespace Sushi.Parsing;

/// <summary>
/// Represents a single node, the smallest unit of code, generated by the parser.
/// </summary>
public abstract class SyntaxNode(Token? token)
{
    /// <summary>
    /// The line the <see cref="SyntaxNode" /> starts at.
    /// </summary>
    public int LineNumber { get; set; } = token?.LineNumber ?? 0;

    /// <summary>
    /// The position of the <see cref="SyntaxNode"/> in the line it appears in.
    /// </summary>
    public int LinePosition { get; set; } = token?.LinePosition ?? 0;

    /// <summary>
    /// Visits a node.
    /// </summary>
    /// <param name="context">
    /// The context that describes and mutates the current state of the parser.
    /// </param>
    /// <returns>
    /// An awaitable <see cref="Task"/> that returns whether the <see cref="Token"/> was consumed.
    /// </returns>
    public virtual async Task<bool> Visit([NotNull] ParsingContext context)
    {
        if (context.IsAtEnd())
        {
            context.Errors.Add(new CompilerError(context.Previous())
            {
                ErrorReason = "Unexpected end of file."
            });

            return false;
        }

        Token token = context.Peek()!;

        return token.Type switch
        {
            TokenType.Whitespace or TokenType.Newline => await this.VisitWhitespace(context),
            TokenType.LineComment or TokenType.BlockComment => await this.VisitComment(context),
            TokenType.Keyword => await this.VisitKeyword(context),
            TokenType.Identifier => await this.VisitIdentifier(context),
            TokenType.Terminator => await this.VisitTerminator(context),
            TokenType.AssignmentOperator => await this.VisitAssignment(context),
            TokenType.NumberLiteral => await this.VisitNumberLiteral(context),
            TokenType.OpeningParenthesis => await this.VisitOpeningParenthesis(context),
            TokenType.ClosingParenthesis => await this.VisitClosingParenthesis(context),
            TokenType.OpeningSquiggly => await this.VisitOpeningSquiggly(context),
            TokenType.ClosingSquiggly => await this.VisitClosingSquiggly(context),
            _ => false
        };
    }

    /// <summary>
    /// Visits an opening squiggly <see cref="Token"/>.
    /// </summary>
    /// <param name="context">
    /// The context that describes and mutates the current state of the parser.
    /// </param>
    /// <returns>
    /// An awaitable <see cref="Task"/> that returns whether the <see cref="Token"/> was consumed.
    /// </returns>
    public virtual Task<bool> VisitOpeningSquiggly([NotNull] ParsingContext context) => Task.FromResult(false);

    /// <summary>
    /// Visits a closing squiggly <see cref="Token"/>.
    /// </summary>
    /// <param name="context">
    /// The context that describes and mutates the current state of the parser.
    /// </param>
    /// <returns>
    /// An awaitable <see cref="Task"/> that returns whether the <see cref="Token"/> was consumed.
    /// </returns>
    public virtual Task<bool> VisitClosingSquiggly([NotNull] ParsingContext context) => Task.FromResult(false);

    /// <summary>
    /// Visits an opening parenthesis <see cref="Token"/>.
    /// </summary>
    /// <param name="context">
    /// The context that describes and mutates the current state of the parser.
    /// </param>
    /// <returns>
    /// An awaitable <see cref="Task"/> that returns whether the <see cref="Token"/> was consumed.
    /// </returns>
    public virtual Task<bool> VisitOpeningParenthesis([NotNull] ParsingContext context) => Task.FromResult(false);

    /// <summary>
    /// Visits a closing parenthesis <see cref="Token"/>.
    /// </summary>
    /// <param name="context">
    /// The context that describes and mutates the current state of the parser.
    /// </param>
    /// <returns>
    /// An awaitable <see cref="Task"/> that returns whether the <see cref="Token"/> was consumed.
    /// </returns>
    public virtual Task<bool> VisitClosingParenthesis([NotNull] ParsingContext context) => Task.FromResult(false);

    /// <summary>
    /// Visits a terminator <see cref="Token"/>.
    /// </summary>
    /// <param name="context">
    /// The context that describes and mutates the current state of the parser.
    /// </param>
    /// <returns>
    /// An awaitable <see cref="Task"/> that returns whether the <see cref="Token"/> was consumed.
    /// </returns>
    public virtual Task<bool> VisitTerminator([NotNull] ParsingContext context) => Task.FromResult(false);

    /// <summary>
    /// Visits a number literal <see cref="Token"/>.
    /// </summary>
    /// <param name="context">
    /// The context that describes and mutates the current state of the parser.
    /// </param>
    /// <returns>
    /// An awaitable <see cref="Task"/> that returns whether the <see cref="Token"/> was consumed.
    /// </returns>
    public virtual Task<bool> VisitNumberLiteral([NotNull] ParsingContext context) => Task.FromResult(false);

    /// <summary>
    /// Visits an identifier <see cref="Token"/>.
    /// </summary>
    /// <param name="context">
    /// The context that describes and mutates the current state of the parser.
    /// </param>
    /// <returns>
    /// An awaitable <see cref="Task"/> that returns whether the <see cref="Token"/> was consumed.
    /// </returns>
    public virtual Task<bool> VisitIdentifier([NotNull] ParsingContext context) => Task.FromResult(false);

    /// <summary>
    /// Visits a whitespace <see cref="Token"/>.
    /// </summary>
    /// <param name="context">
    /// The context that describes and mutates the current state of the parser.
    /// </param>
    /// <returns>
    /// An awaitable <see cref="Task"/> that returns whether the <see cref="Token"/> was consumed.
    /// </returns>
    public virtual async Task<bool> VisitWhitespace([NotNull] ParsingContext context)
    {
        // Unless a node explicitly accepts whitespace tokens, throw it away
        context.Pop();

        // Almost certainly we are visiting for... not the whitespace so re-up the original visit
        return await this.Visit(context);
    }

    /// <summary>
    /// Visits a keyword <see cref="Token"/>.
    /// </summary>
    /// <param name="context">
    /// The context that describes and mutates the current state of the parser.
    /// </param>
    /// <returns>
    /// An awaitable <see cref="Task"/> that returns whether the <see cref="Token"/> was consumed.
    /// </returns>
    public virtual Task<bool> VisitKeyword([NotNull] ParsingContext context) => Task.FromResult(false);

    /// <summary>
    /// Visits an assignment <see cref="Token"/>.
    /// </summary>
    /// <param name="context">
    /// The context that describes and mutates the current state of the parser.
    /// </param>
    /// <returns>
    /// An awaitable <see cref="Task"/> that returns whether the <see cref="Token"/> was consumed.
    /// </returns>
    public virtual Task<bool> VisitAssignment([NotNull] ParsingContext context) => Task.FromResult(false);

    /// <summary>
    /// Visits a comment <see cref="Token"/>.
    /// </summary>
    /// <param name="context">
    /// The context that describes and mutates the current state of the parser.
    /// </param>
    /// <returns>
    /// An awaitable <see cref="Task"/> that returns whether the <see cref="Token"/> was consumed.
    /// </returns>
    public virtual async Task<bool> VisitComment([NotNull] ParsingContext context)
    {
        // Unless a node explicitly accepts comment tokens (don't ever do this), throw it away
        context.Pop();

        // Almost certainly we are visiting for... not the comment so re-up the original visit
        return await this.Visit(context);
    }
}
